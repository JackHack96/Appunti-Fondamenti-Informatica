% ATTENZIONE! Nel documento uso tikz, però sono ancora un nabbo e quindi potreste trovare porcherie
\documentclass[a4paper,oneside]{scrbook}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{xcolor}
\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usetikzlibrary{calc}
\usepackage{pgfplots}
\usepackage{tikz-qtree,tikz-qtree-compat}

\newcommand{\greenmark}{\quad \textcolor{green}{\checkmark}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}

%opening
\title{Manuale di sopravvivenza per l'esame Fondamenti di Informatica}
\subtitle{Una guida pratica per chi deve affrontare questo esame apparentemente insormontabile}
\author{Matteo Iervasi}
\date{Aprile 2018}

\begin{document}
	
\maketitle
\tableofcontents

\chapter*{Prefazione}
\addcontentsline{toc}{chapter}{Prefazione}
Questo documento ha lo scopo di dare un'idea al povero studente che deve affrontare il temibile esame di \textit{Fondamenti di Informatica} di come si affrontano gli esercizi.\\
\textbf{{\large NON}} tratterò l'aspetto teorico, per tanto assumo che si abbia già studiato (o almeno tentato di studiare) quella parte.
Mi rendo conto che la materia in questione sia piuttosto ostica, ma vi posso assicurare che una volta compresi i concetti base il resto verrà da se.
Ovviamente è \textbf{fondamentale} fare molti esercizi, in modo da verificare e consolidare l'apprendimento. Cercherò di essere il più chiaro possibile, ma non essendo mai stato bravo
a spiegare potrebbero esserci dei punti non chiari, per i quali chiedo scusa in anticipo.

Voglio ringraziare Jenny Bonato per l'immensa pazienza che ha avuto per insegnare a questo somaro le basi di questa materia.

Qualora dovreste trovare degli errori, scrivetemi a \href{mailto:matteoiervasi@gmail.com}{matteoiervasi@gmail.com}, oppure fate direttamente una ‘‘\textit{pull request}’’ nel repository GitHub.

\chapter{Linguaggi regolari}
Anche se molto spesso il primo esercizio non tratta un linguaggio regolare, è sempre utile sapere come si deve procedere.

Come dice il prof. Giacobazzi, la prima cosa da fare quando si osserva un linguaggio è capire \textit{intuitivamente} a che classe appartiene (regolare, CF, ecc.).
L'intuizione può essere allenata con la pratica, tuttavia esiste un trucco molto utile: se nel linguaggio è necessario ‘‘contare’’ in qualche modo qualcosa, allora \textbf{sicuramente}
questo linguaggio non sarà regolare. Dopo aver intuitivamente classificato il linguaggio bisogna procedere con la dimostrazione. Nel caso in cui il linguaggio sia \textbf{regolare}, bisogna costruire l'automa e dimostrarne la correttezza.

Ricordiamo che un'automa è scrivibile come una quintupla $<Q,\Sigma,\delta,q_0,F>$, dove:
\begin{itemize}
	\item $Q$ è l'insieme degli stati
	\item $\Sigma$ è l'alfabeto di input
	\item $\delta:Q\times\Sigma\rightarrow Q$ è la funzione di transizione di uno stato
	\item $q_0$ è lo stato iniziale
	\item $F\subseteq Q$ è l'insieme degli stati finali
\end{itemize}

Prendiamo in esame il seguente linguaggio:
$$ L=\{\{0,1\}^* \text{ t.c. ci sono almeno due 0 consecutivi e non ci sono mai due 1 consecutivi}\} $$

Disegniamo l'automa corrispondente (non mi soffermo sul come farlo, questo è argomento del corso di Architettura degli Elaboratori):
\begin{center}
	\begin{tikzpicture}[scale=0.2]
	\tikzstyle{every node}+=[inner sep=0pt]
	\draw [black] (10.3,-30.4) circle (3);
	\draw (10.3,-30.4) node {$q_0$};
	\draw [black] (23.6,-21.3) circle (3);
	\draw (23.6,-21.3) node {$q_1$};
	\draw [black] (23.6,-41) circle (3);
	\draw (23.6,-41) node {$q_4$};
	\draw [black] (44.1,-21.3) circle (3);
	\draw (44.1,-21.3) node {$q_2$};
	\draw [black] (44.1,-21.3) circle (2.4);
	\draw [black] (44.1,-41.9) circle (3);
	\draw (44.1,-41.9) node {$q_3$};
	\draw [black] (44.1,-41.9) circle (2.4);
	\draw [black] (34.5,-51.6) circle (3);
	\draw (34.5,-51.6) node {$q_\bot$};
	\draw [black] (12.78,-28.71) -- (21.12,-22.99);
	\fill [black] (21.12,-22.99) -- (20.18,-23.03) -- (20.75,-23.86);
	\draw (18.1,-26.35) node [below] {$0$};
	\draw [black] (12.65,-32.27) -- (21.25,-39.13);
	\fill [black] (21.25,-39.13) -- (20.94,-38.24) -- (20.32,-39.02);
	\draw (15.79,-36.19) node [below] {$1$};
	\draw [black] (22.648,-38.157) arc (-164.71686:-195.28314:26.582);
	\fill [black] (22.65,-38.16) -- (22.92,-37.25) -- (21.95,-37.52);
	\draw (21.21,-31.15) node [left] {$1$};
	\draw [black] (24.462,-24.172) arc (13.77659:-13.77659:29.302);
	\fill [black] (24.46,-24.17) -- (24.17,-25.07) -- (25.14,-24.83);
	\draw (25.81,-31.15) node [right] {$0$};
	\draw [black] (25.75,-43.09) -- (32.35,-49.51);
	\fill [black] (32.35,-49.51) -- (32.12,-48.59) -- (31.43,-49.31);
	\draw (27.88,-46.78) node [below] {$1$};
	\draw [black] (26.6,-21.3) -- (41.1,-21.3);
	\fill [black] (41.1,-21.3) -- (40.3,-20.8) -- (40.3,-21.8);
	\draw (33.85,-21.8) node [below] {$0$};
	\draw [black] (44.91,-18.423) arc (192.01279:-95.98721:2.25);
	\draw (49.78,-15.79) node [above] {$0$};
	\fill [black] (46.88,-20.19) -- (47.76,-20.52) -- (47.55,-19.54);
	\draw [black] (45.211,-24.085) arc (18.18012:-18.18012:24.087);
	\fill [black] (45.21,-39.12) -- (45.94,-38.51) -- (44.99,-38.2);
	\draw (46.91,-31.6) node [right] {$1$};
	\draw [black] (41.99,-44.03) -- (36.61,-49.47);
	\fill [black] (36.61,-49.47) -- (37.53,-49.25) -- (36.82,-48.55);
	\draw (38.78,-45.27) node [left] {$1$};
	\draw [black] (43.177,-39.047) arc (-165.0509:-194.9491:28.868);
	\fill [black] (43.18,-24.15) -- (42.49,-24.8) -- (43.45,-25.05);
	\draw (41.7,-31.6) node [left] {$0$};
	\end{tikzpicture}
\end{center}
Ora è necessario dimostrare la correttezza dell'automa.
Dobbiamo dimostrare che $x\in L \Leftrightarrow x\in L(n)$, tuttavia non dimostriamo in maniera diretta la doppia implicazione, ma dimostriamo separatamente le seguenti:
\begin{enumerate}
	\item $x\in L \Rightarrow x \in L(m)$
	\item $x\notin L \Rightarrow x \notin L(m)$
\end{enumerate}
\begin{enumerate}
	\item $x\in L \Rightarrow x \in L(m)$\\
	Innanzitutto ci troviamo un \textbf{caso base} utile per il \textbf{passo induttivo}. Qual'è la stringa più piccola $\in L$? È ‘‘$00$’’\\
	\textbf{Passo base}\\
	$ \delta(q_0,00)=q_2 \in F \greenmark $\\
	\textbf{Passo induttivo}\\
	Supponiamo che $\forall x \text{ t.c. } |x|=n \quad x \in L \Rightarrow x\in L(n)$.\\
	Prendiamo allora una stringa $y$ t.c. $|y|>n$ e $y=xa \text{ con }a\in\varepsilon$.\\
	Visto che la funzione di transizione gode della proprietà della composizione, posso considerare $\delta(\delta(q_0,x),a)$.
	Nel nostro caso però abbiamo due stati finali, $q_2$ e $q_3$, quindi dobbiamo guardare entrambi.
	\begin{itemize}
		\item $\delta(q_0,x)=q_2$\\
		Se $a=0$ allora $\delta(q_2,0)=q_2 \in F \greenmark$\\
		Se $a=1$ allora $\delta(q_2,1)=q_3 \in F \greenmark$
		\item $\delta(q_0,x)=q_3$\\
		Se $a=0$ allora $\delta(q_3,0)=q_2 \in F \greenmark$\\
		Se $a=1$ allora $\delta(q_3,1)=q_\bot \notin F \greenmark$ (è giusto visto che in questo caso $y\notin L$, dato che ci sarebbero due 1 consecutivi)
	\end{itemize}
	
	\item $x\notin L \Rightarrow x \notin L(m)$\\
	In questa caso dobbiamo trovare i casi che \textbf{NON} finiscono in stati finali.\\
	\textbf{Passo base}\\
	$x=0 \rightarrow \delta(q_0,0)=q_1 \notin F \text{ (non ho almeno due 0 consecutivi)} \greenmark$\\
	$x=11 \rightarrow \delta(q_0,11)=q_\bot \notin F \text{ (ho due 1 consecutivi)} \greenmark$\\
	$x=\varepsilon \rightarrow \delta(q_0,\varepsilon)=q_0 \notin F \greenmark$\\
	$x=1 \rightarrow \delta(q_0,1)=q_4 \notin F \greenmark$\\
	\textbf{Passo induttivo}\\
	Supponiamo che $\forall x \text{ t.c. } |x|=n \quad x \notin L \Rightarrow x\notin L(n)$.\\
	Prendiamo allora una stringa $y$ t.c. $|y|>n$ e $y=xa \text{ con }a\in\varepsilon$. Ricordiamoci che possiamo usare $\delta(\delta(q_0,x),a)$.\\
	In modo analogo alla precedente dimostrazione, dobbiamo considerare gli stati non finali.
	\begin{itemize}
		\item $\delta(q_0,x)=q_0$\\
		Se $a=0$ allora $\delta(q_0,0)=q_1 \notin F \greenmark$\\
		Se $a=1$ allora $\delta(q_0,1)=q_4 \notin F \greenmark$
		\item $\delta(q_0,x)=q_1$\\
		Se $a=0$ allora $\delta(q_1,0)=q_2 \in F \greenmark$ (è giusto visto che in questo caso $y\in L$, dato che ci sono \textbf{almeno} due 0 consecutivi)\\
		Se $a=1$ allora $\delta(q_1,1)=q_4 \notin F \greenmark$
		\item $\delta(q_0,x)=q_4$\\
		Se $a=0$ allora $\delta(q_4,0)=q_1 \notin F \greenmark$\\
		Se $a=1$ allora $\delta(q_4,1)=q_\bot \notin F \greenmark$
		\item $\delta(q_0,x)=q_\bot$\\
		Se $a=0$ allora $\delta(q_\bot,0)=q_\bot \notin F \greenmark$\\
		Se $a=1$ allora $\delta(q_\bot,1)=q_\bot \notin F \greenmark$
	\end{itemize}
\end{enumerate}
Abbiamo quindi dimostrato la doppia implicazione e con essa la \textit{correttezza} del nostro automa.

Facciamo un altro esempio, prendiamo come linguaggio
$$ L=\{\{0,1\}^* \text{ t.c. gli 0 sono sempre a coppie}\} $$
Ecco l'automa:
\begin{center}
	\begin{tikzpicture}[scale=0.2]
	\tikzstyle{every node}+=[inner sep=0pt]
	\draw [black] (20.9,-26.9) circle (3);
	\draw (20.9,-26.9) node {$q_0$};
	\draw [black] (20.9,-26.9) circle (2.4);
	\draw [black] (36.2,-26.9) circle (3);
	\draw (36.2,-26.9) node {$q_1$};
	\draw [black] (50.6,-26.9) circle (3);
	\draw (50.6,-26.9) node {$qb$};
	\draw [black] (23.732,-25.918) arc (104.62203:75.37797:19.088);
	\fill [black] (33.37,-25.92) -- (32.72,-25.23) -- (32.47,-26.2);
	\draw (28.55,-24.8) node [above] {$0$};
	\draw [black] (33.33,-27.765) arc (-77.20264:-102.79736:21.58);
	\fill [black] (23.77,-27.77) -- (24.44,-28.43) -- (24.66,-27.46);
	\draw (28.55,-28.8) node [below] {$0$};
	\draw [black] (39.2,-26.9) -- (47.6,-26.9);
	\fill [black] (47.6,-26.9) -- (46.8,-26.4) -- (46.8,-27.4);
	\draw (43.4,-27.4) node [below] {$1$};
	\draw [black] (53.28,-25.577) arc (144:-144:2.25);
	\draw (57.85,-26.9) node [right] {$0,1$};
	\fill [black] (53.28,-28.22) -- (53.63,-29.1) -- (54.22,-28.29);
	\draw [black] (18.22,-28.223) arc (-36:-324:2.25);
	\draw (13.65,-26.9) node [left] {$1$};
	\fill [black] (18.22,-25.58) -- (17.87,-24.7) -- (17.28,-25.51);
	\end{tikzpicture}
\end{center}
Dobbiamo dimostrare che $x\in L \Leftrightarrow x\in L(n)$:
\begin{enumerate}
	\item $x\in L \Rightarrow x \in L(m)$
	\item $x\notin L \Rightarrow x \notin L(m)$
\end{enumerate}
\begin{enumerate}
	\item $x\in L \Rightarrow x \in L(m)$\\
	\textbf{Passo base}\\
	$ x=00 \rightarrow \delta(q_0,00)=q_0 \in F \greenmark $\\
	\textbf{Passo induttivo}\\
	Supponiamo che $\forall x \text{ t.c. } |x|=n \quad x \in L \Rightarrow x\in L(n)$.\\
	Prendiamo allora una stringa $y$ t.c. $|y|>n$ e $y=xa \text{ con }a\in\varepsilon$.\\
	Visto che la funzione di transizione gode della proprietà della composizione, posso considerare $\delta(\delta(q_0,x),a)$.\\
	$\delta(q_0,x)=q_0$\\
	Se $a=0$ allora $\delta(q_0,0)=q_1 \notin F \greenmark$\\
	Se $a=1$ allora $\delta(q_0,1)=q_0 \in F \greenmark$
	
	\item $x\notin L \Rightarrow x \notin L(m)$\\
	\textbf{Passo base}\\
	$x=0 \rightarrow \delta(q_0,0)=q_1 \notin F \greenmark$\\
	$x=1 \rightarrow \delta(q_0,1)=q_1 \notin F \greenmark$\\
	\textbf{Passo induttivo}\\
	Supponiamo che $\forall x \text{ t.c. } |x|=n \quad x \notin L \Rightarrow x\notin L(n)$.\\
	Prendiamo allora una stringa $y$ t.c. $|y|>n$ e $y=xa \text{ con }a\in\varepsilon$. Ricordiamoci che possiamo usare $\delta(\delta(q_0,x),a)$.\\
	In modo analogo alla precedente dimostrazione, dobbiamo considerare gli stati non finali.
	\begin{itemize}
		\item $\delta(q_0,x)=q_1$\\
		Se $a=0$ allora $\delta(q_1,0)=q_0 \in F \greenmark$\\
		Se $a=1$ allora $\delta(q_1,1)=q_\bot \notin F \greenmark$
		\item $\delta(q_0,x)=q_\bot$\\
		Se $a=0$ allora $\delta(q_\bot,0)=q_\bot \notin F \greenmark$\\
		Se $a=1$ allora $\delta(q_\bot,1)=q_\bot \notin F \greenmark$
	\end{itemize}
\end{enumerate}
Abbiamo quindi dimostrato la doppia implicazione e con essa la \textit{correttezza} del nostro automa.

\chapter{Linguaggi liberi dal contesto e grammatiche}
Questa categoria è più rognosa di quella dei regolari, ma fortunatamente se dovesse capitarci non dobbiamo costruire un'automa. Dobbiamo però costruire la grammatica,
una procedura non sempre immediata purtroppo. Un utile trucco per riconoscere un linguaggio CF è immaginare un'automa con una pila: ad esempio se dobbiamo riconoscere il linguaggio
$0^n1^n$ il nostro automa mano a mano che legge gli $0$ li mette in una pila, dopodiché leggendo gli $1$ la scarica, e se a fine stringa la pila è vuota allora il linguaggio è riconosciuto.\\
\textit{Nota}: l'automa non è costretto a leggere linearmente la stringa, nell'esempio di prima possiamo anche leggere gli 1 a partire dal fondo, facendo valere la stessa regola dello
svuotamento della pila.

Prendiamo in esame il seguente linguaggio 
$$L=\{x\in\{0,1\}^*\text{ t.c. ci siano tanti 0 quanti 1}\}$$
Intuitivamente notiamo che è necessario ‘‘contare’’ il numero di $0$ e far si che sia uguale al numero di $1$. Esempi di possibili combinazioni:
\begin{itemize}
	\item $01$
	\item $00001111$
	\item $01010101$
	\item $011010$
\end{itemize}
Notiamo che non è necessario che ci sia una determinata sequenza, basta solo che gli $0$ totali siano uguali agli $1$.
Pensandoci un po', viene naturale classificare questo linguaggio nella classe dei \textit{context free}.
Per dimostrarlo occorre prima applicare il cosiddetto \textbf{pumping lemma}, in modo da mostrare che non può essere regolare.
Successivamente dobbiamo scrivere una \textbf{grammatica} che genera il linguaggio e \textbf{dimostrarne la correttezza}.\\
\textbf{Fase 1: Pumping Lemma}\\
In questa fase ci basta prendere una stringa appartenente al linguaggio e dimostrare che ‘‘pompandone’’ una parte noi usciamo dal linguaggio.
Ricordiamoci che nell'applicare il pumping lemma dobbiamo sottostare a dei vincoli:
\begin{itemize}
	\item $z=uvw$
	\item $|uv|\leq n$
	\item $|v|>0$
	\item $\forall i \in \mathbb{N}.uv^iw\in L \text{ con }i\geq0$
\end{itemize}
Ovviamente non siamo stupidi, quindi scegliamo una stringa facile, in questo caso $z=0^n1^n$.
L'unica suddivisione possibile è:
\begin{center}
	\begin{tikzpicture}
	% String rectangle
	\draw (0,0.75) -- (0,1.25) node(0){};
	\draw (0,0.75) -- (5,0.75) node[midway,above]{0};
	\draw (5,0.75) -- (5,1.25) node(5){};
	\draw (5,0.75) -- (10,0.75) node[midway,above]{1};
	\draw (10,0.75) -- (10,1.25) node(10){};
	
	% Bracket rectangle
	\draw [decorate, decoration={brace, amplitude=5pt, raise=2.5pt}] (0.north east) -- (5.north west) node [midway, above=0.2cm] {n};
	\draw [decorate, decoration={brace, amplitude=5pt, raise=2.5pt}] (5.north east) -- (10.north west) node [midway, above=0.2cm] {n};
	
	% String division rectangle
	\draw (0,0) -- (0,0.5);
	\draw (0,0) -- (2.5,0) node[midway,above]{$u$};
	\draw (2.5,0) -- (2.5,0.5);
	\draw (2.5,0) -- (5,0) node[midway,above]{$v$};
	\draw (5,0) -- (5,0.5);
	\draw (5,0) -- (10,0) node[midway,above]{$w$};
	\draw (10,0) -- (10,0.5);
	\end{tikzpicture}
\end{center}
La stringa apparterrà al linguaggio solamente se $0^a1^b\in L \Leftrightarrow a=b$.\\
La nostra stringa $z$ sarà quindi composta da $0^{k-|v|}0^{\textbf{i}|v|}1^k$. Per soddisfare la condizione appena scritta sopra $k-|v|+|v|i=k$, quindi:\\
$-|v|+|v|i=0$\\
$|v|(i-1)=0$\\
Ma questo è un assurdo! Infatti $|v|$ non può essere uguale a $0$ per i vincoli del pumping lemma.
Vediamo che per $i=0 \wedge i\geq2$ usciamo dal linguaggio, quindi possiamo dire che è sicuramente non regolare. $\greenmark$\\
\textbf{Fase 2: Grammatica}\\
Una possibile grammatica per questo linguaggio è:
$$S \rightarrow 0S1|01|10$$
Ed ecco una possibile derivazione:
\begin{center}
	\begin{tikzpicture}
	\Tree
	[.\blue{\blue{S}}
		[.0\blue{S}1
			[.00\blue{S}11	001011 ]
			[.01\blue{S}01 011011 ]
			[.0011  ]
			[.0101  ]
		]
		[.1\blue{S}0
			[.10\blue{S}10 101010 ]
			[.11\blue{S}00 111000 ]
			[.1010  ]
			[.1100  ]
		]
		[.01  ]
		[.10  ]
	]
	\end{tikzpicture}
\end{center}
\textbf{Fase 3: Dimostrazione della grammatica}\\
Per dimostrare la correttezza della nostra grammatica, dobbiamo dimostrare la seguente condizione:
$$x\in L \Leftrightarrow S \Rightarrow_* x$$
Essendo una doppia implicazione, dimostreremo separatamente
\begin{enumerate}
	\item $x\in L \Rightarrow S \Rightarrow_* x $, che si dimostra per \textit{induzione} sulla lunghezza della stringa
	\item $ S \Rightarrow_i k \Rightarrow x \in L$, che si dimostra per \textit{induzione} sul numero di passi di derivazione
\end{enumerate}
\begin{enumerate}
	\item $x\in L \Rightarrow S \Rightarrow_* x $\\
	\textbf{Passo base}\\
	$y=01 \qquad y \in L$ ed $\exists S\Rightarrow 01 \greenmark $ (esiste una derivazione S che porta ad $01$).\\		$y=10 \qquad y \in L$ ed $\exists S\Rightarrow 10 \greenmark $ (esiste una derivazione S che porta ad $10$).\\
	\textbf{Passo induttivo}\\
	Consideriamo $y \in \varepsilon^*$ tale che $|y|<n$ e supponiamo che $\forall y \in L \Rightarrow S \Rightarrow_* y$.\\
	Allora prendiamo $|x|\geq n$ e sapendo che $y$ è composto come $y=0^k1^k$, $x$ sarà $0^m1^m$ con $m>k$. Procediamo prendendo $m=k+1$:
	$$ x=0^{k+1}1^{k+1}$$
	Sappiamo per ipotesi che esiste una derivazione  $S\Rightarrow_i 0^k1^k$, quindi
	$$\exists S \Rightarrow y \rightarrow \exists S \Rightarrow_i 0^k1^k$$
	ma se esiste questa esiste anche la derivazione precedente, ovvero
	$$\exists S \Rightarrow_{i-1} 0^{k-1}S1^{k-1} ...$$
	essendo che la produzione $S\rightarrow 0S1$ appartiene all'insieme delle possibili produzioni, posso sostituire:
	$$... \Rightarrow_i 0^{k-1}0S11^{k-1} \Rightarrow_{i+1} 0^k011^k = 0^{k+1}1^{k+1} = x \greenmark$$
	In pratica siamo tornati indietro di un passo e abbiamo applicato una sostituzione che ci conducesse alla stringa $x$.\\
	Ripetiamo lo stesso procedimento per $y=1^k0^k$ e $x=1^{k+1}0^{k+1}$:
	$$\exists S \Rightarrow y \rightarrow \exists S \Rightarrow_i 1^k0^k \Rightarrow_{i-1} 1^{k-1}S0^{k-1}$$
	$$\Rightarrow_i 1^{k-1}1S00^{k-1} \Rightarrow_{i+1} 1^k100^k = 1^{k+1}0^{k+1} = x \greenmark$$
	
	\item $ S \Rightarrow_i k \Rightarrow x \in L$\\
	\textbf{Passo base}\\
	$S\rightarrow 01 \qquad x=01 \quad x \in L$\\
	$S\rightarrow 10 \qquad x=10 \quad x \in L$\\
	\textbf{Passo induttivo}\\
	$\forall i \leq n \quad S \Rightarrow_i y \Rightarrow y \in L $ (in $i$ passi otteniamo una stringa $\in L$, per ogni $i\leq n$).
	Sappiamo che $y$ sarà nella forma $0^k1^k$ visto che $\in L$, quindi $S \Rightarrow_i 0^k1^k$. Ma se esiste quella produzione, allora
	esisterà anche quella precedente. Con lo stesso gioco che abbiamo applicato nella dimostrazione precedente, andiamo indietro per poi
	andare avanti con una produzione:
	$$S \Rightarrow_i 0^k1^k \Rightarrow \exists S \Rightarrow_{i-1} 0^{k-1}S1^{k-1}$$
	$$\Rightarrow_i 0^{k-1}0S11^{k-1} \Rightarrow_{i+1} 0^k011^k = 0^{k+1}1^{k+1} \in L \greenmark$$
	Per $y=1^k0^k$:
	$$S \Rightarrow_i 1^k0^k \Rightarrow \exists S \Rightarrow_{i-1} 1^{k-1}S0^{k-1}$$
	$$\Rightarrow_i 1^{k-1}1S00^{k-1} \Rightarrow_{i+1} 1^k100^k = 1^{k+1}0^{k+1} \in L \greenmark$$
	In pratica mostriamo che andando avanti otteniamo una stringa che appartiene ancora al linguaggio.
\end{enumerate}

Facciamo un altro esempio, prendiamo come linguaggio
$$L={a^nb^n}$$
Sappiamo che è CF perché è necessario ‘‘tener conto’’ di quante $a$ sono state riconosciute per verificare che siano pari al numero di $b$.\\
\textbf{Fase 1: Pumping Lemma}\\
Scegliamo una stringa facile che rispetti i vincoli, come $a^nb^n$.
\begin{itemize}
	\item $z=uvw$
	\item $|uv|\leq n$
	\item $|v|>0$
	\item $\forall i \in \mathbb{N}.uv^iw\in L \text{ con }i\geq0$
\end{itemize}
L'unica suddivisione possibile è:
\begin{center}
	\begin{tikzpicture}
	% String rectangle
	\draw (0,0.75) -- (0,1.25) node(0){};
	\draw (0,0.75) -- (5,0.75) node[midway,above]{a};
	\draw (5,0.75) -- (5,1.25) node(5){};
	\draw (5,0.75) -- (10,0.75) node[midway,above]{b};
	\draw (10,0.75) -- (10,1.25) node(10){};
	
	% Bracket rectangle
	\draw [decorate, decoration={brace, amplitude=5pt, raise=2.5pt}] (0.north east) -- (5.north west) node [midway, above=0.2cm] {n};
	\draw [decorate, decoration={brace, amplitude=5pt, raise=2.5pt}] (5.north east) -- (10.north west) node [midway, above=0.2cm] {n};
	
	% String division rectangle
	\draw (0,0) -- (0,0.5);
	\draw (0,0) -- (2.5,0) node[midway,above]{$u$};
	\draw (2.5,0) -- (2.5,0.5);
	\draw (2.5,0) -- (5,0) node[midway,above]{$v$};
	\draw (5,0) -- (5,0.5);
	\draw (5,0) -- (10,0) node[midway,above]{$w$};
	\draw (10,0) -- (10,0.5);
	\end{tikzpicture}
\end{center}
La stringa apparterrà al linguaggio solamente se $a^xb^y\in L \Leftrightarrow x=y$.\\
La nostra stringa $z$ sarà quindi composta da $a^{k-|v|}a^{\textbf{i}|v|}b^k$. Per soddisfare la condizione appena scritta sopra $k-|v|+|v|i=k$, quindi:\\
$-|v|+|v|i=0$\\
$|v|(i-1)=0$\\
Ma questo è un assurdo! Infatti $|v|$ non può essere uguale a $0$ per i vincoli del pumping lemma.
Vediamo che per $i=0 \wedge i\geq2$ usciamo dal linguaggio, quindi possiamo dire che è sicuramente non regolare.$\greenmark$\\
\textbf{Fase 2: Grammatica}\\
Una possibile grammatica per questo linguaggio è:
$$S \rightarrow aSb|ab$$
Mentre una possibile derivazione per questa grammatica è:
\begin{center}
	\begin{tikzpicture}
	\Tree
	[.\blue{S}
		[.a\blue{S}b
			[.aa\blue{S}bb aaabbb ]
			[.aabb  ]
		]
		[.ab  ]
	]
	\end{tikzpicture}
\end{center}
\textbf{Fase 3: Dimostrazione della grammatica}\\
Per dimostrare la correttezza della nostra grammatica, dobbiamo dimostrare la seguente condizione:
$$x\in L \Leftrightarrow S \Rightarrow_* x$$
Essendo una doppia implicazione, dimostreremo separatamente
\begin{enumerate}
	\item $x\in L \Rightarrow S \Rightarrow_* x $, che si dimostra per \textit{induzione} sulla lunghezza della stringa
	\item $ S \Rightarrow_i k \Rightarrow x \in L$, che si dimostra per \textit{induzione} sul numero di passi di derivazione
\end{enumerate}
\begin{enumerate}
	\item $x\in L \Rightarrow S \Rightarrow_* x $\\
	\textbf{Passo base}\\
	$y=ab \qquad y \in L$ ed $\exists S\Rightarrow ab \greenmark$ (esiste una derivazione S che porta ad $ab$).\\
	\textbf{Passo induttivo}\\
	Consideriamo $y \in \varepsilon^*$ tale che $|y|<n$ e supponiamo che $\forall y \in L \Rightarrow S \Rightarrow_* y$.\\
	Allora prendiamo $|x|\geq n$ e sapendo che $y$ è composto come $y=a^kb^k$, $x$ sarà $x=a^mb^m$ con $m>k$. Procediamo prendendo $m=k+1$:
	$$ x=a^{k+1}b^{k+1}$$
	Sappiamo per ipotesi che esiste una derivazione  $S\Rightarrow_i a^kb^k$, quindi
	$$\exists S \Rightarrow y \rightarrow \exists S \Rightarrow_i a^kb^k$$
	ma se esiste questa esiste anche la derivazione precedente, ovvero
	$$\exists S \Rightarrow_{i-1} a^{k-1}Sb^{k-1} ...$$
	essendo che la produzione $S\rightarrow aSb$ appartiene all'insieme delle possibili produzioni, posso sostituire:
	$$... \Rightarrow_i a^{k-1}aSbb^{k-1} \Rightarrow_{i+1} a^kabb^k = a^{k+1}b^{k+1} = x \greenmark$$
	In pratica siamo tornati indietro di un passo e abbiamo applicato una sostituzione che ci conducesse alla stringa $x$.
	
	\item $ S \Rightarrow_i k \Rightarrow x \in L$\\
	\textbf{Passo base}\\
	$S\rightarrow ab \qquad x=ab \quad x \in L$\\
	\textbf{Passo induttivo}\\
	$\forall i \leq n \quad S \Rightarrow_i y \Rightarrow y \in L $ (in $i$ passi otteniamo una stringa $\in L$, per ogni $i\leq n$).
	Sappiamo che $y$ sarà nella forma $a^kb^k$ visto che $\in L$, quindi $S \Rightarrow_i a^kb^k$. Ma se esiste quella produzione, allora
	esisterà anche quella precedente. Con lo stesso gioco che abbiamo applicato nella dimostrazione precedente, andiamo indietro per poi
	andare avanti con una produzione:
	$$S \Rightarrow_i a^kb^k \Rightarrow \exists S \Rightarrow_{i-1} a^{k-1}Sb^{k-1}$$
	$$\Rightarrow_i a^{k-1}aSbb^{k-1} \Rightarrow_{i+1} a^kabb^k = a^{k+1}b^{k+1} \in L \greenmark$$
\end{enumerate}

\chapter{Linguaggi non liberi dal contesto}
Quando un linguaggio richiede più di un singolo conteggio per essere riconosciuto, allora è molto probabile che non sia libero dal contesto.
In quel caso, si procede utilizzando il \textbf{pumping lemma} per i linguaggi CF, in modo da dimostrare la sua non appartenenza a questa classe.
A differenza del pumping lemma per i linguaggi regolari, le suddivisioni possibili sono molte di più, e bisogna dimostrare la fuoriuscita per ognuna di esse.

Prendiamo in esempio il linguaggio
$$L=\{a^nb^nc^n\}$$
Esso è chiaramente non-CF, infatti $|a|=|b|=|c|$ e quindi dobbiamo contare due volte, cosa non possibile in un'automa a pila.
Posto che $\forall z$ tale che $|z|>n$, dobbiamo soddisfare i seguenti vincoli:
\begin{itemize}
    \item $\forall z = uvwxy$
    \item $|vwx| \leq n$
    \item $|vx|>0$
    \item $uv^iwx^iy\in L$
\end{itemize}
Elenchiamo le diverse possibili suddivisioni:
\begin{center}
    \begin{tikzpicture}
    % Defining main coordinates
    \coordinate (a0) at (0,0);
	\coordinate (b0) at (5,0);
	\coordinate (c0) at (10,0);
	\coordinate (d0) at (15,0);
    \coordinate (a1) at (0,0.5);
    \coordinate (b1) at (5,0.5);
    \coordinate (c1) at (10,0.5);
    \coordinate (d1) at (15,0.5);
    
    % Bracket rectangle
    \draw [decorate, decoration={brace, amplitude=5pt, raise=2.5pt}] ($(a1)+(0,0.5*8)$.north east) -- ($(b1)+(0,0.5*8)$.north west) node [midway, above=0.2cm] {n};
    \draw [decorate, decoration={brace, amplitude=5pt, raise=2.5pt}] ($(b1)+(0,0.5*8)$.north east) -- ($(c1)+(0,0.5*8)$.north west) node [midway, above=0.2cm] {n};
    \draw [decorate, decoration={brace, amplitude=5pt, raise=2.5pt}] ($(c1)+(0,0.5*8)$.north east) -- ($(d1)+(0,0.5*8)$.north west) node [midway, above=0.2cm] {n};
    
    % Original string rectangle
    % |_a_
    \draw ($(a0)+(0,0.5*8)$) -- ($(a1)+(0,0.5*8)$);
    \draw ($(a0)+(0,0.5*8)$) -- ($(b0)+(0,0.5*8)$) node[midway,above]{a};
    % |_b_
    \draw ($(b0)+(0,0.5*8)$) -- ($(b1)+(0,0.5*8)$);
    \draw ($(b0)+(0,0.5*8)$) -- ($(c0)+(0,0.5*8)$) node[midway,above]{b};
    % |_c
    \draw ($(c0)+(0,0.5*8)$) -- ($(c1)+(0,0.5*8)$);
    \draw ($(c0)+(0,0.5*8)$) -- ($(d0)+(0,0.5*8)$) node[midway,above]{c};
    % |
    \draw ($(d0)+(0,0.5*8)$) -- ($(d1)+(0,0.5*8)$);
    
    % Possible divisions rectangles
    \draw ($(a0)+(0,0.5*7-0.25)$) -- ($(a1)+(0,0.5*7-0.25)$);
    \draw ($(a0)+(0,0.5*7-0.25)$) -- ($(b0)+(-1.5,0.5*7-0.25)$) node[midway,above]{$u$};
    \draw ($(b0)+(-1.5,0.5*7-0.25)$) -- ($(b1)+(-1.5,0.5*7-0.25)$);
    \draw ($(b0)+(-1.5,0.5*7-0.25)$) -- ($(b0)+(1.5,0.5*7-0.25)$) node[midway,above]{$v$};
%    \draw ($(b0)+(1.5,0.5*7-0.25)$)
    \end{tikzpicture}
\end{center}

\chapter{Esercizi vari}
Classificare le seguenti famiglie di linguaggi al variare di $n,m \in \mathbb{N}$ (N.B. $0\in\mathbb{N}$), motivando formalmente la risposta:
\begin{align*}
	&A_{m,n} =\{ \sigma \in \{1,0\}^* | \text{ } \sigma = (1^{2n}001^m)^n \}\\
	&B_m = \bigcup_{n\in\mathbb{N}} A_{m,n}\\
	&C_n = \bigcup_{m\in\mathbb{N}} A_{m,n}
\end{align*}
Innanzitutto notiamo che il linguaggio, al variare di $m,n$, rimane un linguaggio regolare, ad esempio:
\begin{align*}
	&A_{0,0}=\varnothing\\
	&A_{1,1}=11001\\
	&A_{0,1}=1100\\
	&A_{1,0}=\varnothing\\
	&A_{2,1}=110011\\
	&A_{2,2}=1111001111110011\\
	&\dots
\end{align*}
Quindi prendiamo un esempio facile e dimostriamo la correttezza del suo automa. Scegliamo $L=A_{2,1}$.
\begin{center}
	\begin{tikzpicture}[scale=0.2]
	\tikzstyle{every node}+=[inner sep=0pt]
	\draw [black] (6.3,-19.7) circle (3);
	\draw (6.3,-19.7) node {$q_0$};
	\draw [black] (16.9,-19.7) circle (3);
	\draw (16.9,-19.7) node {$q_1$};
	\draw [black] (29.2,-19.7) circle (3);
	\draw (29.2,-19.7) node {$q_2$};
	\draw [black] (40.5,-19.7) circle (3);
	\draw (40.5,-19.7) node {$q_3$};
	\draw [black] (51.8,-19.7) circle (3);
	\draw (51.8,-19.7) node {$q_4$};
	\draw [black] (63.5,-19.7) circle (3);
	\draw (63.5,-19.7) node {$q_5$};
	\draw [black] (74.9,-19.7) circle (3);
	\draw (74.9,-19.7) node {$q_6$};
	\draw [black] (74.9,-19.7) circle (2.4);
	\draw [black] (40.5,-38.1) circle (3);
	\draw (40.5,-38.1) node {$\bot$};
	\draw [black] (19.9,-19.7) -- (26.2,-19.7);
	\fill [black] (26.2,-19.7) -- (25.4,-19.2) -- (25.4,-20.2);
	\draw (23.05,-20.2) node [below] {$1$};
	\draw [black] (32.2,-19.7) -- (37.5,-19.7);
	\fill [black] (37.5,-19.7) -- (36.7,-19.2) -- (36.7,-20.2);
	\draw (34.85,-20.2) node [below] {$0$};
	\draw [black] (43.5,-19.7) -- (48.8,-19.7);
	\fill [black] (48.8,-19.7) -- (48,-19.2) -- (48,-20.2);
	\draw (46.15,-20.2) node [below] {$0$};
	\draw [black] (54.8,-19.7) -- (60.5,-19.7);
	\fill [black] (60.5,-19.7) -- (59.7,-19.2) -- (59.7,-20.2);
	\draw (57.65,-20.2) node [below] {$1$};
	\draw [black] (66.5,-19.7) -- (71.9,-19.7);
	\fill [black] (71.9,-19.7) -- (71.1,-19.2) -- (71.1,-20.2);
	\draw (69.2,-20.2) node [below] {$1$};
	\draw [black] (9.3,-19.7) -- (13.9,-19.7);
	\fill [black] (13.9,-19.7) -- (13.1,-19.2) -- (13.1,-20.2);
	\draw (11.6,-20.2) node [below] {$1$};
	\draw [black] (8.94,-21.12) -- (37.86,-36.68);
	\fill [black] (37.86,-36.68) -- (37.39,-35.86) -- (36.92,-36.74);
	\draw (22.26,-29.4) node [below] {$0$};
	\draw [black] (19.27,-21.54) -- (38.13,-36.26);
	\fill [black] (38.13,-36.26) -- (37.81,-35.37) -- (37.2,-36.16);
	\draw (27.54,-29.4) node [below] {$0$};
	\draw [black] (30.77,-22.26) -- (38.93,-35.54);
	\fill [black] (38.93,-35.54) -- (38.94,-34.6) -- (38.09,-35.12);
	\draw (34.21,-30.18) node [left] {$0$};
	\draw [black] (40.5,-22.7) -- (40.5,-35.1);
	\fill [black] (40.5,-35.1) -- (41,-34.3) -- (40,-34.3);
	\draw (40,-28.9) node [left] {$0$};
	\draw [black] (50.23,-22.26) -- (42.07,-35.54);
	\fill [black] (42.07,-35.54) -- (42.91,-35.12) -- (42.06,-34.6);
	\draw (45.51,-27.62) node [left] {$0$};
	\draw [black] (61.16,-21.57) -- (42.84,-36.23);
	\fill [black] (42.84,-36.23) -- (43.78,-36.12) -- (43.15,-35.34);
	\draw (50.84,-28.41) node [above] {$0$};
	\draw [black] (72.25,-21.11) -- (43.15,-36.69);
	\fill [black] (43.15,-36.69) -- (44.09,-36.75) -- (43.61,-35.87);
	\draw (56.56,-28.4) node [above] {$0$};
	\end{tikzpicture}
\end{center}
Dobbiamo dimostrare che $x\in L \Leftrightarrow L(m)$:
\begin{enumerate}
	\item $x\in L \Rightarrow x \in L(m)$\\
	Essendo un linguaggio finito, non è difficile dimostrare che l'unica stringa riconosciuta dall'automa è $110011$.
	$$\delta(q_0,110011)=q_6\in F \greenmark$$
	\item $x\notin L \Rightarrow x \notin L(m)$\\
	Essendo un linguaggio finito, qualsiasi stringa diversa da $110011$ non viene riconosciuta.
\end{enumerate}
Abbiamo quindi dimostrato la doppia implicazione e con essa la \textit{correttezza} del nostro automa.

Adesso guardiamo l'unione in $n$ del linguaggio $A_{m,n}$:
$$ B_m = \bigcup_{n\in\mathbb{N}} A_{m,n} $$
\begin{itemize}
	\item $B_0=(1^{2n}00)^n$
	\item $B_1=(1^{2n}001)^n$
	\item $B_2=(1^{2n}0011)^n$
\end{itemize}
Notiamo che, al variare di $m$, otteniamo sempre e comunque un linguaggio CF.
Procediamo quindi con il pumping lemma, la grammatica e la dimostrazione della grammatica.
\textbf{Fase 1: Pumping Lemma}\\
In questa fase ci basta prendere una stringa appartenente al linguaggio e dimostrare che ‘‘pompandone’’ una parte noi usciamo dal linguaggio.
Ricordiamoci che nell'applicare il pumping lemma dobbiamo sottostare a dei vincoli:
\begin{itemize}
	\item $z=uvw$
	\item $|uv|\leq n$
	\item $|v|>0$
	\item $\forall i \in \mathbb{N}.uv^iw\in L \text{ con }i\geq0$
\end{itemize}
Ovviamente non siamo stupidi, quindi scegliamo una stringa facile, in questo caso $z=0^n1^n$.
L'unica suddivisione possibile è:
\begin{center}
	\begin{tikzpicture}
	% String rectangle
	\draw (0,0.75) -- (0,1.25) node(0){};
	\draw (0,0.75) -- (5,0.75) node[midway,above]{0};
	\draw (5,0.75) -- (5,1.25) node(5){};
	\draw (5,0.75) -- (10,0.75) node[midway,above]{1};
	\draw (10,0.75) -- (10,1.25) node(10){};
	
	% Bracket rectangle
	\draw [decorate, decoration={brace, amplitude=5pt, raise=2.5pt}] (0.north east) -- (5.north west) node [midway, above=0.2cm] {n};
	\draw [decorate, decoration={brace, amplitude=5pt, raise=2.5pt}] (5.north east) -- (10.north west) node [midway, above=0.2cm] {n};
	
	% String division rectangle
	\draw (0,0) -- (0,0.5);
	\draw (0,0) -- (2.5,0) node[midway,above]{$u$};
	\draw (2.5,0) -- (2.5,0.5);
	\draw (2.5,0) -- (5,0) node[midway,above]{$v$};
	\draw (5,0) -- (5,0.5);
	\draw (5,0) -- (10,0) node[midway,above]{$w$};
	\draw (10,0) -- (10,0.5);
	\end{tikzpicture}
\end{center}
La stringa apparterrà al linguaggio solamente se $0^a1^b\in L \Leftrightarrow a=b$.\\
La nostra stringa $z$ sarà quindi composta da $0^{k-|v|}0^{\textbf{i}|v|}1^k$. Per soddisfare la condizione appena scritta sopra $k-|v|+|v|i=k$, quindi:\\
$-|v|+|v|i=0$\\
$|v|(i-1)=0$\\
Ma questo è un assurdo! Infatti $|v|$ non può essere uguale a $0$ per i vincoli del pumping lemma.
Vediamo che per $i=0 \wedge i\geq2$ usciamo dal linguaggio, quindi possiamo dire che è sicuramente non regolare. $\greenmark$\\
\textbf{Fase 2: Grammatica}\\
Una possibile grammatica per questo linguaggio è:
$$S \rightarrow 0S1|01|10$$
Ed ecco una possibile derivazione:
\begin{center}
	\begin{tikzpicture}
	\Tree
	[.\blue{\blue{S}}
	[.0\blue{S}1
	[.00\blue{S}11	001011 ]
	[.01\blue{S}01 011011 ]
	[.0011  ]
	[.0101  ]
	]
	[.1\blue{S}0
	[.10\blue{S}10 101010 ]
	[.11\blue{S}00 111000 ]
	[.1010  ]
	[.1100  ]
	]
	[.01  ]
	[.10  ]
	]
	\end{tikzpicture}
\end{center}
\textbf{Fase 3: Dimostrazione della grammatica}\\
Per dimostrare la correttezza della nostra grammatica, dobbiamo dimostrare la seguente condizione:
$$x\in L \Leftrightarrow S \Rightarrow_* x$$
Essendo una doppia implicazione, dimostreremo separatamente
\begin{enumerate}
	\item $x\in L \Rightarrow S \Rightarrow_* x $, che si dimostra per \textit{induzione} sulla lunghezza della stringa
	\item $ S \Rightarrow_i k \Rightarrow x \in L$, che si dimostra per \textit{induzione} sul numero di passi di derivazione
\end{enumerate}
\begin{enumerate}
	\item $x\in L \Rightarrow S \Rightarrow_* x $\\
	\textbf{Passo base}\\
	$y=01 \qquad y \in L$ ed $\exists S\Rightarrow 01 \greenmark $ (esiste una derivazione S che porta ad $01$).\\		$y=10 \qquad y \in L$ ed $\exists S\Rightarrow 10 \greenmark $ (esiste una derivazione S che porta ad $10$).\\
	\textbf{Passo induttivo}\\
	Consideriamo $y \in \varepsilon^*$ tale che $|y|<n$ e supponiamo che $\forall y \in L \Rightarrow S \Rightarrow_* y$.\\
	Allora prendiamo $|x|\geq n$ e sapendo che $y$ è composto come $y=0^k1^k$, $x$ sarà $0^m1^m$ con $m>k$. Procediamo prendendo $m=k+1$:
	$$ x=0^{k+1}1^{k+1}$$
	Sappiamo per ipotesi che esiste una derivazione  $S\Rightarrow_i 0^k1^k$, quindi
	$$\exists S \Rightarrow y \rightarrow \exists S \Rightarrow_i 0^k1^k$$
	ma se esiste questa esiste anche la derivazione precedente, ovvero
	$$\exists S \Rightarrow_{i-1} 0^{k-1}S1^{k-1} ...$$
	essendo che la produzione $S\rightarrow 0S1$ appartiene all'insieme delle possibili produzioni, posso sostituire:
	$$... \Rightarrow_i 0^{k-1}0S11^{k-1} \Rightarrow_{i+1} 0^k011^k = 0^{k+1}1^{k+1} = x \greenmark$$
	In pratica siamo tornati indietro di un passo e abbiamo applicato una sostituzione che ci conducesse alla stringa $x$.\\
	Ripetiamo lo stesso procedimento per $y=1^k0^k$ e $x=1^{k+1}0^{k+1}$:
	$$\exists S \Rightarrow y \rightarrow \exists S \Rightarrow_i 1^k0^k \Rightarrow_{i-1} 1^{k-1}S0^{k-1}$$
	$$\Rightarrow_i 1^{k-1}1S00^{k-1} \Rightarrow_{i+1} 1^k100^k = 1^{k+1}0^{k+1} = x \greenmark$$
	
	\item $ S \Rightarrow_i k \Rightarrow x \in L$\\
	\textbf{Passo base}\\
	$S\rightarrow 01 \qquad x=01 \quad x \in L$\\
	$S\rightarrow 10 \qquad x=10 \quad x \in L$\\
	\textbf{Passo induttivo}\\
	$\forall i \leq n \quad S \Rightarrow_i y \Rightarrow y \in L $ (in $i$ passi otteniamo una stringa $\in L$, per ogni $i\leq n$).
	Sappiamo che $y$ sarà nella forma $0^k1^k$ visto che $\in L$, quindi $S \Rightarrow_i 0^k1^k$. Ma se esiste quella produzione, allora
	esisterà anche quella precedente. Con lo stesso gioco che abbiamo applicato nella dimostrazione precedente, andiamo indietro per poi
	andare avanti con una produzione:
	$$S \Rightarrow_i 0^k1^k \Rightarrow \exists S \Rightarrow_{i-1} 0^{k-1}S1^{k-1}$$
	$$\Rightarrow_i 0^{k-1}0S11^{k-1} \Rightarrow_{i+1} 0^k011^k = 0^{k+1}1^{k+1} \in L \greenmark$$
	Per $y=1^k0^k$:
	$$S \Rightarrow_i 1^k0^k \Rightarrow \exists S \Rightarrow_{i-1} 1^{k-1}S0^{k-1}$$
	$$\Rightarrow_i 1^{k-1}1S00^{k-1} \Rightarrow_{i+1} 1^k100^k = 1^{k+1}0^{k+1} \in L \greenmark$$
	In pratica mostriamo che andando avanti otteniamo una stringa che appartiene ancora al linguaggio.
\end{enumerate}

Per quanto riguarda l'unione in $m$ del linguaggio $A_{m,n}$:
$$ C_n = \bigcup_{m\in\mathbb{N}} A_{m,n} $$


\chapter{Teoria della ricorsione}
TODO
\end{document}